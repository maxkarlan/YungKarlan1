<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streams Flowing Downward with p5.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
<script>
let streams = [];
let circleRadiusOptions = [];
let circleRadius;
let shapeType;
let randomMovement = true;
let obstacles = [];
let pressCount = 0;
let bgWhite;
const numOfObstacles = 20;  // Or any other number you like


function setup() {
    let canvasSize = min(windowWidth, windowHeight);
    createCanvas(canvasSize, canvasSize);
    circleRadiusOptions = [3, 6, 12];
    circleRadius = width / random(circleRadiusOptions);

    let shapeTypeOptions = ['circle', 'square', 'triangle'];
    shapeType = random(shapeTypeOptions);
    console.log("radius:", circleRadius);
    let densityStreams = [150, 450, 750];
    let numOfStreams = random(densityStreams);
    console.log("density:", numOfStreams);
    let colorGroupFunctions = [redGroup, blueGroup, greenGroup, whiteGroup, purpleGroup, peachGroup, cottonCandyGroup, morningStarGroup];
    let selectedFunction = random(colorGroupFunctions);
    bgWhite = random() < .5;
    console.log("color:", selectedFunction);
    // console.log(selectedFunction, "color");
    for (let i = 0; i < numOfStreams; i++) {
        let col = selectedFunction();
        streams.push(new Stream(col));
    }
    for (let i = 0; i < numOfObstacles; i++) {
        obstacles.push(new Obstacle());
    }
}

function redGroup () {
    return col = color(random(100, 255), 0, random(0,155));
}

function blueGroup () {
    return col = color(0, random(0, 155), random(100, 255));
}

function greenGroup () {
    return col = color(random(0, 155), random(100, 255), 0);
}

function whiteGroup () {
    colorMode(HSB);
    return col = color(0, 0, random(35,100));
}

function purpleGroup() {
    return col = color(220, random(0, 155), random(200, 255));
}

function peachGroup() {
    return col = color(255, random(75, 155), random(0, 125));
}

function cottonCandyGroup() {
    return col = color(random(150, 255), random(100, 200), 255);
}

function morningStarGroup() {
    let mainColor = random() < .85;
    if (mainColor) {
        return col = color(random(0, 255), 0, 0);
    } else {
        return col = color(255, random(215, 255), 255, 155);
    }
}

function draw() {
    if (bgWhite) {
        background(255);
        fill(0); // color for the frame
    } else {
        background(0);
        fill(255);
    }
            

                // Draw the frame
    let frameSize = width * (1/20);

    noStroke();
    rect(frameSize * (3/4), frameSize * (3/4), frameSize/4, height - frameSize * (3/2));
    rect(width - (frameSize), frameSize * (3/4), frameSize/4, height - frameSize * (3/2));
    rect(frameSize * (3/4), frameSize * (3/4), width - frameSize * (3/2), frameSize/4);
    rect(frameSize * (3/4), height - (frameSize), width - frameSize * (3/2), frameSize/4);

            // Draw the circle in the center of the window
            noFill();
            noStroke();
            ellipse(width / 2, height / 2, 2 * circleRadius);

            for (let s of streams) {
                s.update();
                s.display();
            }
        }

function mousePressed() {
    pressCount++;

    if (pressCount % 2 === 0) {
        // Every other time starting from the second time
        obstacles = [];  // Clear existing obstacles
        for (let i = 0; i < numOfObstacles; i++) {
            obstacles.push(new Obstacle());
        }
    }

    randomMovement = !randomMovement;
    for (let s of streams) {
        s.changeMovement(randomMovement);
    }
  
  return false; // This prevents any default behavior
}



 class Obstacle {
    constructor() {
        this.position = createVector(random(width), random(height));
        this.radius = random(20, 160);
        while (this.overlapsWithMainShape()) {
            this.position = createVector(random(width), random(height));
        }
    }

    overlapsWithMainShape() {
        if (shapeType === 'circle') {
            return dist(this.position.x, this.position.y, width / 2, height / 2) < (circleRadius + this.radius);
        } else if (shapeType === 'square') {
            // Can rename variable later, but let's say that `circleRadius` is the side length of the square
            return this.position.x > width / 2 - (circleRadius + this.radius) / 2 && this.position.x < width / 2 + (circleRadius + this.radius) / 2 && this.position.y > height / 2 - (circleRadius + this.radius) / 2 && this.position.y < height / 2 + (circleRadius + this.radius) / 2;
        } else {
            // Can rename variable later, but `circleRadius` is the side length of the triangle
            // See if point is within the triangle
            let x1 = width / 2 - (circleRadius + this.radius) / 2;
            let y1 = height / 2 + (circleRadius + this.radius) / 2;
            let x2 = width / 2 + (circleRadius + this.radius) / 2;
            let y2 = height / 2 + (circleRadius + this.radius) / 2;
            let x3 = width / 2;
            let y3 = height / 2 - (circleRadius + this.radius) / 2;
            let denominator = (y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3);
            let a = ((y2 - y3) * (this.position.x - x3) + (x3 - x2) * (this.position.y - y3)) / denominator;
            let b = ((y3 - y1) * (this.position.x - x3) + (x1 - x3) * (this.position.y - y3)) / denominator;
            let c = 1 - a - b;
            return 0 <= a && a <= 1 && 0 <= b && b <= 1 && 0 <= c && c <= 1;
        }
    }

    display() {
        fill(150);
        noStroke();
        ellipse(this.position.x, this.position.y, this.radius * 2);
    }
}
      
        class Stream {
            constructor(color) {
                this.justBounced = false;
                this.color = color;
                this.points = [];
                this.noiseOffset = random(1000);
                this.currentAngle = random(TWO_PI);
                this.initStream();
                this.randomMovement = true;
            }

initStream() {
    let startX, startY;
    do {
        startX = random(width);
        startY = random(height);
    } while (!this.isInsideShape(createVector(startX, startY))); // changed this condition

    this.points.push(createVector(startX, startY));
}

            update() {
                let lastPoint = this.points[this.points.length - 1];

    if (this.insideCircle) {
        // Random movement inside the circle
        let angleVariation = map(noise(this.noiseOffset), 0, 1, -PI / 4, PI / 4);
        this.currentAngle += angleVariation;
    } else if (this.randomMovement) {
        // Scatter movement
        let angleVariation = map(noise(this.noiseOffset), 0, 1, -PI / 4, PI / 4);
        this.currentAngle += angleVariation;
    } else {
        // Magnetized movement towards the circle
        this.currentAngle = this.angleToCircleBorder(lastPoint);
    }

    if (this.justBounced) {
        // Disable noise influence for some frames after bouncing
        // You can adjust the number of frames as needed
        this.framesAfterBounce = (this.framesAfterBounce || 0) + 1;
        if (this.framesAfterBounce > 5) {  // Example: 10 frames
            this.justBounced = false;
            this.framesAfterBounce = 0;
        }
    } else {
        this.noiseOffset += 0.05;  // Update noise offset if not recently bounced
    }
              

    let len = 5;
    let newPoint = p5.Vector.fromAngle(this.currentAngle).mult(len).add(lastPoint);

              
              
    if (this.isInsideShape(newPoint) && !this.insideCircle && this.randomMovement) {
        // If the stream is about to enter the circle and is not allowed to, bounce it away
        let angleToCenter = this.angleToCircleBorder(newPoint);
        this.currentAngle = 2 * angleToCenter - PI - this.currentAngle;
        newPoint = p5.Vector.fromAngle(this.currentAngle).mult(len).add(lastPoint);
        this.justBounced = true;
    }

    if (this.isInsideShape(newPoint)) {
        this.insideCircle = true;
    } else {
        this.insideCircle = false;
    }
              for (let obstacle of obstacles) {
    let distance = dist(lastPoint.x, lastPoint.y, obstacle.position.x, obstacle.position.y);
    if (distance < obstacle.radius) {
        // Repulsion effect
let angleToObstacle = atan2(obstacle.position.x - lastPoint.x, obstacle.position.y - lastPoint.y);
let deviationAngle = this.currentAngle - angleToObstacle;

if (abs(deviationAngle) < PI / 2) {
    this.currentAngle += map(distance, 0, obstacle.radius, -PI / 4, PI / 4);
} else {
    this.currentAngle -= map(distance, 0, obstacle.radius, -PI / 4, PI / 4);
}

        // Update newPoint after obstacle interaction
        newPoint = p5.Vector.fromAngle(this.currentAngle).mult(len).add(lastPoint);

    }
}

          
                // Bounce off the canvas boundaries
                if (newPoint.x <= width * (1/20) || newPoint.x >= width * (19/20)) {
                    this.currentAngle = PI - this.currentAngle;
                    this.justBounced = true;
                }
                if (newPoint.y <= height * (1/20) || newPoint.y >= height * (19/20)) {
                    this.currentAngle = - this.currentAngle;
                    this.justBounced = true;
                }
              
                newPoint = p5.Vector.fromAngle(this.currentAngle).mult(len).add(lastPoint);

                // Check again if new point is outside the boundary, and adjust if necessary
                if (newPoint.x <= width * (1/20) || newPoint.x >= width * (19/20) || newPoint.y <= height * (1/20) || newPoint.y >= height * (19/20)) {
                    newPoint = p5.Vector.fromAngle(this.currentAngle).mult(len).add(lastPoint);
                }

                this.points.push(newPoint);
                if (this.justBounced) {

                } else {
                this.noiseOffset += 0.05;
                }

                if (this.points.length > 100) {
                    this.points.shift();
                }
            }
          
            angleToCircleBorder(point) {
                return atan2(height / 2 - point.y, width / 2 - point.x);
            }
          
            changeMovement(randomMovement) {
                this.randomMovement = randomMovement;
                if (randomMovement) {
                    this.insideCircle = false; // Ensure stream is set as outside the circle
                }
            }
          
            isInsideShape(point) {
                if (shapeType === 'circle') {
                    return dist(point.x, point.y, width / 2, height / 2) < circleRadius;
                } else if (shapeType === 'square') {
                    // Can rename variable later, but let's say that `circleRadius` is the side length of the square
                    return point.x > width / 2 - circleRadius / 2 && point.x < width / 2 + circleRadius / 2 && point.y > height / 2 - circleRadius / 2 && point.y < height / 2 + circleRadius / 2;
                } else {
                    // Can rename variable later, but `circleRadius` is the side length of the triangle
                    // See if point is within the triangle
                    let x1 = width / 2 - circleRadius / 2;
                    let y1 = height / 2 + circleRadius / 2;
                    let x2 = width / 2 + circleRadius / 2;
                    let y2 = height / 2 + circleRadius / 2;
                    let x3 = width / 2;
                    let y3 = height / 2 - circleRadius / 2;
                    let denominator = (y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3);
                    let a = ((y2 - y3) * (point.x - x3) + (x3 - x2) * (point.y - y3)) / denominator;
                    let b = ((y3 - y1) * (point.x - x3) + (x1 - x3) * (point.y - y3)) / denominator;
                    let c = 1 - a - b;
                    return 0 <= a && a <= 1 && 0 <= b && b <= 1 && 0 <= c && c <= 1;
                }
            }

            display() {
                noFill();
                stroke(this.color);
                strokeWeight(1);
                beginShape();
                for (let pt of this.points) {
                    vertex(pt.x, pt.y);
                }
                endShape();
            }
        }
</script>
</body>
</html>
